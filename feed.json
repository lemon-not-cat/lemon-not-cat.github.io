{
    "version": "https://jsonfeed.org/version/1",
    "title": "灵韵流光",
    "subtitle": "犬吠水声中，桃花带露浓。 树深时见鹿，溪午不闻钟。 野竹分青霭，飞泉挂碧峰。 无人知所去，愁倚两三松。",
    "icon": "https://lemon-not-cat.github.io/images/favicon.ico",
    "description": "对Java的探索 & 编程笔记",
    "home_page_url": "https://lemon-not-cat.github.io",
    "items": [
        {
            "id": "https://lemon-not-cat.github.io/2024/03/31/back-end/java/redis/redis/",
            "url": "https://lemon-not-cat.github.io/2024/03/31/back-end/java/redis/redis/",
            "title": "redis",
            "date_published": "2024-03-31T07:26:58.000Z",
            "content_html": "<h1 id=\"持久化\"><a class=\"anchor\" href=\"#持久化\">#</a> 持久化</h1>\n<h2 id=\"1-aof\"><a class=\"anchor\" href=\"#1-aof\">#</a> 1、AOF</h2>\n<ul>\n<li>首先根据 redis 里面的内存数据重新构建一个 AOF 文件</li>\n<li>读取 redis 里面的数据，写入到新的 AOF 文件中</li>\n<li>用新的 AOF 文件覆盖掉现有的 AOF 文件</li>\n<li>redis 把重写这个过程放到子进程中去完成，不影响主进程工作</li>\n<li>为了避免子进程在重写过程中主进程的数据发生变化，redis 把主进程的数据变更追加到 AOF 重写缓冲区中，等到 AOF 文件重写完成后，再将 AOF 重写缓冲区里面的数据追加到新的 AOF 文件里面</li>\n</ul>\n<h2 id=\"2-rdb\"><a class=\"anchor\" href=\"#2-rdb\">#</a> 2、RDB</h2>\n<ul>\n<li>首先会生成一个 fork 子进程，fork 子进程共享 redis 主进程中的内存数据，fork 子进程用来进行 RDB 持久化操作。</li>\n<li>fork 子进程将 redis 内存数据写入到 dump.rmb 临时文件中，写入完成后替换掉最终的 dump.rmb 文件，完成一次持久化。</li>\n<li>当 redis 宕机重启后，redis 会读取 dump.rmb 文件，将数据加载到 redis 内存中。</li>\n</ul>\n<p>持久化还有两种方式，手动触发和自动触发</p>\n<ul>\n<li>手动触发只需要执行 save 或 bgsave 命令即可<br />\n save：save 命令执行时，会阻塞 redis 进程，直到持久化完成才可以进行其他操作<br />\n bgsave：bgsave 命令执行时是异步持久化的，会生成一个 fork 子进程，子进程进行持久化，不影响主进程</li>\n<li>自动触发需要在 redis.conf 中配置，通过 save 配置项，配置 RDB 持久化的规则，当满足规则时候，redis 就会自动执行一次持久化操作</li>\n</ul>\n<h1 id=\"缓存击穿-缓存穿透-缓存雪崩\"><a class=\"anchor\" href=\"#缓存击穿-缓存穿透-缓存雪崩\">#</a> 缓存击穿、缓存穿透、缓存雪崩</h1>\n<h2 id=\"缓存击穿\"><a class=\"anchor\" href=\"#缓存击穿\">#</a> 缓存击穿</h2>\n<p><strong>概念</strong>：指热点 key 在某个时间点过期的时候，而恰好在这个时间点对这个 Key 有大量的并发请求过来，从而大量的请求打到 db。<strong>解决方案就有两种：</strong></p>\n<ul>\n<li>使用互斥锁方案。缓存失效时，不是立即去加载 db 数据，而是先使用某些带成功返回的原子操作命令，如 (Redis 的 setnx) 去操作，成功的时候，再去加载 db 数据库数据和设置缓存。否则就去重试获取缓存。</li>\n<li>“永不过期”，是指没有设置过期时间，但是热点数据快要过期时，异步线程去更新和设置过期时间。</li>\n</ul>\n<h2 id=\"缓存穿透\"><a class=\"anchor\" href=\"#缓存穿透\">#</a> 缓存穿透</h2>\n<p><strong>概念</strong> ：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，进而给数据库带来压力。<strong>缓存穿透一般都是这几种情况产生的：</strong></p>\n<ul>\n<li><strong>业务不合理的设计</strong>，比如大多数用户都没开守护，但是你的每个请求都去缓存，查询某个 userid 查询有没有守护。</li>\n<li><strong>业务 / 运维 / 开发失误的操作</strong>，比如缓存和数据库的数据都被误删除了。</li>\n<li><strong>黑客非法请求攻击</strong>，比如黑客故意捏造大量非法请求，以读取不存在的业务数据。</li>\n</ul>\n<p><strong>如何避免缓存穿透呢？</strong></p>\n<ul>\n<li>如果是非法请求，我们在 API 入口，对参数进行校验，过滤非法值。</li>\n<li>如果查询数据库为空，我们可以给缓存设置个空值，或者默认值。但是如有有写请求进来的话，需要更新缓存哈，以保证缓存一致性，同时，最后给缓存设置适当的过期时间。（业务上比较常用，简单有效）</li>\n<li>使用布隆过滤器快速判断数据是否存在。即一个查询请求过来时，先通过布隆过滤器判断值是否存在，存在才继续往下查。</li>\n</ul>\n<h2 id=\"缓存雪崩\"><a class=\"anchor\" href=\"#缓存雪崩\">#</a> 缓存雪崩</h2>\n<p><strong>概念</strong>：指缓存中数据大批量到过期时间，而查询数据量巨大，请求都直接访问数据库，引起数据库压力过大甚至 down 机。<strong>解决方案</strong>：</p>\n<ul>\n<li>缓存雪奔一般是由于大量数据同时过期造成的，对于这个原因，可通过均匀设置过期时间解决，即让过期时间相对离散一点。如采用一个较大固定值 + 一个较小的随机值，5 小时 + 0 到 1800 秒酱紫。</li>\n<li>Redis 故障宕机也可能引起缓存雪奔。这就需要构造 Redis 高可用集群啦。</li>\n</ul>\n<h1 id=\"过期策略\"><a class=\"anchor\" href=\"#过期策略\">#</a> 过期策略</h1>\n<p>我们在 set key 的时候，可以给它设置一个过期时间，比如 expire key 60。指定这 key60s 后过期，60s 后，redis 是如何处理的嘛？我们先来介绍几种过期策略：</p>\n<p>定时过期<br />\n每个设置过期时间的 key 都需要创建一个定时器，到过期时间就会立即对 key 进行清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的 CPU 资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</p>\n<p>惰性过期<br />\n只有当访问一个 key 时，才会判断该 key 是否已过期，过期则清除。该策略可以最大化地节省 CPU 资源，却对内存非常不友好。极端情况可能出现大量的过期 key 没有再次被访问，从而不会被清除，占用大量内存。</p>\n<p>定期过期<br />\n每隔一定的时间，会扫描一定数量的数据库的 expires 字典中一定数量的 key，并清除其中已过期的 key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得 CPU 和内存资源达到最优的平衡效果。expires 字典会保存所有设置了过期时间的 key 的过期时间数据，其中，key 是指向键空间中的某个键的指针，value 是该键的毫秒精度的 UNIX 时间戳表示的过期时间。键空间是指该 Redis 集群中保存的所有键。</p>\n<p>Redis 中同时使用了惰性过期和定期过期两种过期策略：</p>\n<ul>\n<li>假设 Redis 当前存放 30 万个 key，并且都设置了过期时间，如果你每隔 100ms 就去检查这全部的 key，CPU 负载会特别高，最后可能会挂掉。</li>\n<li>因此，redis 采取的是定期过期，每隔 100ms 就随机抽取一定数量的 key 来检查和删除的。</li>\n<li>但是呢，最后可能会有很多已经过期的 key 没被删除。这时候，redis 采用惰性删除。在你获取某个 key 的时候，redis 会检查一下，这个 key 如果设置了过期时间并且已经过期了，此时就会删除。</li>\n</ul>\n<h1 id=\"内存淘汰策略\"><a class=\"anchor\" href=\"#内存淘汰策略\">#</a> 内存淘汰策略</h1>\n<ul>\n<li>volatile-lru：当内存不足以容纳新写入数据时，从设置了过期时间的 key 中使用 LRU（最近最少使用）算法进行淘汰；</li>\n<li>allkeys-lru：当内存不足以容纳新写入数据时，从所有 key 中使用 LRU（最近最少使用）算法进行淘汰。</li>\n<li>volatile-lfu：4.0 版本新增，当内存不足以容纳新写入数据时，在过期的 key 中，使用 LFU 算法进行删除 key。</li>\n<li>allkeys-lfu：4.0 版本新增，当内存不足以容纳新写入数据时，从所有 key 中使用 LFU 算法进行淘汰；</li>\n<li>volatile-random：当内存不足以容纳新写入数据时，从设置了过期时间的 key 中，随机淘汰数据；。</li>\n<li>allkeys-random：当内存不足以容纳新写入数据时，从所有 key 中随机淘汰数据。</li>\n<li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的 key 中，根据过期时间进行淘汰，越早过期的优先被淘汰；</li>\n<li>noeviction：默认策略，当内存不足以容纳新写入数据时，新写入操作会报错。</li>\n</ul>\n<h1 id=\"主从模式\"><a class=\"anchor\" href=\"#主从模式\">#</a> 主从模式</h1>\n<p>主从模式中，Redis 部署了多台机器，有主节点，负责读写操作，有从节点，只负责读操作。从节点的数据来自主节点，实现原理就是<strong>主从复制机制</strong><br />\n主从复制包括全量复制，增量复制两种。一般当 slave 第一次启动连接 master，或者认为是第一次连接，就采用<strong>全量复制</strong> slave 与 master 全量同步之后，master 上的数据，如果再次发生更新，就会触发<strong>增量复制</strong>。</p>\n<p>当 master 节点发生数据增减时，就会触发 replicationFeedSalves () 函数，接下来在 Master 节点上调用的每一个命令会使用 replicationFeedSlaves () 来同步到 Slave 节点。执行此函数之前呢，master 节点会判断用户执行的命令是否有数据更新，如果有数据更新的话，并且 slave 节点不为空，就会执行此函数。这个函数作用就是：<em><strong>把用户执行的命令发送到所有的 slave 节点，让 slave 节点执行。</strong></em></p>\n<h1 id=\"哨兵模式\"><a class=\"anchor\" href=\"#哨兵模式\">#</a> 哨兵模式</h1>\n<p>主从模式中，一旦主节点由于故障不能提供服务，需要人工将从节点晋升为主节点，同时还要通知应用方更新主节点地址。显然，多数业务场景都不能接受这种故障处理方式。Redis 从 2.8 开始正式提供了 Redis Sentinel（哨兵）架构来解决这个问题。</p>\n<p>哨兵模式，由一个或多个 Sentinel 实例组成的 Sentinel 系统，它可以监视所有的 Redis 主节点和从节点，并在被监视的主节点进入下线状态时，自动将下线主服务器属下的某个从节点升级为新的主节点。但是呢，一个哨兵进程对 Redis 节点进行监控，就可能会出现问题（单点问题），因此，可以使用多个哨兵来进行监控 Redis 节点，并且各个哨兵之间还会进行监控。</p>\n<p>简单来说，哨兵模式就三个作用：</p>\n<ul>\n<li>发送命令，等待 Redis 服务器（包括主服务器和从服务器）返回监控其运行状态；</li>\n<li>哨兵监测到主节点宕机，会自动将从节点切换成主节点，然后通过发布订阅模式通知其他的从节点，修改配置文件，让它们切换主机；</li>\n<li>哨兵之间还会相互监控，从而达到高可用。</li>\n</ul>\n<p>故障切换的过程是怎样的呢<br />\n假设主服务器宕机，哨兵 1 先检测到这个结果，系统并不会马上进行 failover 过程，仅仅是哨兵 1 主观的认为主服务器不可用，这个现象成为主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行 failover 操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线。这样对于客户端而言，一切都是透明的。</p>\n<p>哨兵的工作模式如下：</p>\n<ul>\n<li>每个 Sentinel 以每秒钟一次的频率向它所知的 Master，Slave 以及其他 Sentinel 实例发送一个 PING 命令。</li>\n<li>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel 标记为主观下线。</li>\n<li>如果一个 Master 被标记为主观下线，则正在监视这个 Master 的所有 Sentinel 要以每秒一次的频率确认 Master 的确进入了主观下线状态。</li>\n<li>当有足够数量的 Sentinel（大于等于配置文件指定的值）在指定的时间范围内确认 Master 的确进入了主观下线状态， 则 Master 会被标记为客观下线。</li>\n<li>在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率向它已知的所有 Master，Slave 发送 INFO 命令。</li>\n<li>当 Master 被 Sentinel 标记为客观下线时，Sentinel 向下线的 Master 的所有 Slave 发送 INFO 命令的频率会从 10 秒一次改为每秒一次</li>\n<li>若没有足够数量的 Sentinel 同意 Master 已经下线， Master 的客观下线状态就会被移除；若 Master 重新向 Sentinel 的 PING 命令返回有效回复， Master 的主观下线状态就会被移除。</li>\n</ul>\n<h1 id=\"cluster集群模式\"><a class=\"anchor\" href=\"#cluster集群模式\">#</a> Cluster 集群模式</h1>\n<p>哨兵模式基于主从模式，实现读写分离，它还可以自动切换，系统可用性更高。但是它每个节点存储的数据是一样的，浪费内存，并且不好在线扩容。因此，Cluster 集群应运而生，它在 Redis3.0 加入的，实现了 Redis 的分布式存储。对数据进行分片，也就是说每台 Redis 节点上存储不同的内容，来解决在线扩容的问题。并且，它也提供复制和故障转移的功能。</p>\n<p>一个 Redis 集群由多个节点组成，各个节点之间是怎么通信的呢？通过 Gossip 协议！<br />\nRedis Cluster 集群通过 Gossip 协议进行通信，节点之前不断交换信息，交换的信息内容包括节点出现故障、新节点加入、主从节点变更信息、slot 信息等等。常用的 Gossip 消息分为 4 种，分别是：ping、pong、meet、fail。</p>\n<ul>\n<li>meet 消息：通知新节点加入。消息发送者通知接收者加入到当前集群，meet 消息通信正常完成后，接收节点会加入到集群中并进行周期性的 ping、pong 消息交换。</li>\n<li>ping 消息：集群内交换最频繁的消息，集群内每个节点每秒向多个其他节点发送 ping 消息，用于检测节点是否在线和交换彼此状态信息。</li>\n<li>pong 消息：当接收到 ping、meet 消息时，作为响应消息回复给发送方确认消息正常通信。pong 消息内部封装了自身状态数据。节点也可以向集群内广播自身的 pong 消息来通知整个集群对自身状态进行更新。</li>\n<li>fail 消息：当节点判定集群内另一个节点下线时，会向集群内广播一个 fail 消息，其他节点接收到 fail 消息之后把对应节点更新为下线状态。</li>\n</ul>\n<p>特别的，每个节点是通过<strong>集群总线 (cluster bus)</strong> 与其他的节点进行通信的。通讯时，使用特殊的端口号，即对外服务端口号加 10000。例如如果某个 node 的端口号是 6379，那么它与其它 nodes 通信的端口号是 16379。nodes 之间的通信采用特殊的二进制协议。</p>\n<p>Hash Slot 插槽算法<br />\n既然是分布式存储，Cluster 集群使用的分布式算法是一致性 Hash 嘛？并不是，而是 Hash Slot 插槽算法。<br />\n插槽算法把整个数据库被分为 16384 个 slot（槽），每个进入 Redis 的键值对，根据 key 进行散列，分配到这 16384 插槽中的一个。使用的哈希映射也比较简单，用 CRC16 算法计算出一个 16 位的值，再对 16384 取模。数据库中的每个键都属于这 16384 个槽的其中一个，集群中的每个节点都可以处理这 16384 个槽。<br />\n集群中的每个节点负责一部分的 hash 槽，比如当前集群有 A、B、C 个节点，每个节点上的哈希槽数 =16384/3，那么就有：</p>\n<ul>\n<li>节点 A 负责 0~5460 号哈希槽</li>\n<li>节点 B 负责 5461~10922 号哈希槽</li>\n<li>节点 C 负责 10923~16383 号哈希槽</li>\n</ul>\n<p>Redis Cluster 集群中，需要确保 16384 个槽对应的 node 都正常工作，如果某个 node 出现故障，它负责的 slot 也会失效，整个集群将不能工作。<br />\n因此为了保证高可用，Cluster 集群引入了主从复制，一个主节点对应一个或者多个从节点。当其它主节点 ping 一个主节点 A 时，如果半数以上的主节点与 A 通信超时，那么认为主节点 A 宕机了。如果主节点宕机时，就会启用从节点。<br />\n在 Redis 的每一个节点上，都有两个玩意，一个是插槽（slot），它的取值范围是 0~16383。另外一个是 cluster，可以理解为一个集群管理的插件。当我们存取的 key 到达时，Redis 会根据 CRC16 算法得出一个 16 bit 的值，然后把结果对 16384 取模。酱紫每个 key 都会对应一个编号在 0~16383 之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作。<br />\n虽然数据是分开存储在不同节点上的，但是对客户端来说，整个集群 Cluster，被看做一个整体。客户端端连接任意一个 node，看起来跟操作单实例的 Redis 一样。当客户端操作的 key 没有被分配到正确的 node 节点时，Redis 会返回转向指令，最后指向正确的 node，这就有点像浏览器页面的 302 重定向跳转。</p>\n<p>故障转移<br />\n Redis 集群实现了高可用，当集群内节点出现故障时，通过故障转移，以保证集群正常对外提供服务。<br />\nredis 集群通过 ping/pong 消息，实现故障发现。这个环境包括主观下线和客观下线。<br />\n主观下线： 某个节点认为另一个节点不可用，即下线状态，这个状态并不是最终的故障判定，只能代表一个节点的意见，可能存在误判情况。</p>\n<p>主观下线<br />\n客观下线： 指标记一个节点真正的下线，集群内多个节点都认为该节点不可用，从而达成共识的结果。如果是持有槽的主节点故障，需要为该节点进行故障转移。<br />\n假如节点 A 标记节点 B 为主观下线，一段时间后，节点 A 通过消息把节点 B 的状态发到其它节点，当节点 C 接受到消息并解析出消息体时，如果发现节点 B 的 pfail 状态时，会触发客观下线流程；<br />\n当下线为主节点时，此时 Redis Cluster 集群为统计持有槽的主节点投票，看投票数是否达到一半，当下线报告统计数大于一半时，被标记为客观下线状态。</p>\n<p>客观下线<strong>故障恢复</strong>：故障发现后，如果下线节点的是主节点，则需要在它的从节点中选一个替换它，以保证集群的高可用。流程如下：</p>\n<ul>\n<li>资格检查：检查从节点是否具备替换故障主节点的条件。</li>\n<li>准备选举时间：资格检查通过后，更新触发故障选举时间。</li>\n<li>发起选举：到了故障选举时间，进行选举。</li>\n<li>选举投票：只有持有槽的<strong>主节点</strong>才有票，从节点收集到足够的选票（大于一半），触发<strong>替换主节点操作</strong></li>\n</ul>\n<h1 id=\"分布式锁\"><a class=\"anchor\" href=\"#分布式锁\">#</a> 分布式锁</h1>\n<p><strong>分布式锁</strong>，是控制分布式系统不同进程共同访问共享资源的一种锁的实现。秒杀下单、抢红包等等业务场景，都需要用到分布式锁，我们项目中经常使用 Redis 作为分布式锁。</p>\n<h2 id=\"命令setnx-expire分开写\"><a class=\"anchor\" href=\"#命令setnx-expire分开写\">#</a> 命令 setnx + expire 分开写</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>（jedis.setnx(key,lock_value) == <span class=\"number\">1</span>）&#123; </span><br><span class=\"line\">    <span class=\"comment\">//加锁 expire（key，100）; </span></span><br><span class=\"line\">    <span class=\"comment\">//设置过期时间 </span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123; </span><br><span class=\"line\">        <span class=\"comment\">//业务请求 do something </span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span>()&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123; </span><br><span class=\"line\">        jedis.del(key); </span><br><span class=\"line\">        <span class=\"comment\">//释放锁 </span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 如果执行完 setnx 加锁，正要执行 expire 设置过期时间时，进程 crash 掉或者要重启维护了，那这个锁就 “长生不老” 了，别的线程永远获取不到锁啦，所以分布式锁不能这么实现。</p>\n<h2 id=\"setnx-value值是过期时间\"><a class=\"anchor\" href=\"#setnx-value值是过期时间\">#</a> setnx + value 值是过期时间</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">expires</span> <span class=\"operator\">=</span> System.currentTimeMillis() + expireTime; </span><br><span class=\"line\"><span class=\"comment\">//系统时间+设置的过期时间 </span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">expiresStr</span> <span class=\"operator\">=</span> String.valueOf(expires); </span><br><span class=\"line\"><span class=\"comment\">// 如果当前锁不存在，返回加锁成功 </span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (jedis.setnx(key, expiresStr) == <span class=\"number\">1</span>) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"comment\">// 如果锁已经存在，获取锁的过期时间 </span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">currentValueStr</span> <span class=\"operator\">=</span> jedis.get(key); </span><br><span class=\"line\"><span class=\"comment\">// 如果获取到的过期时间，小于系统当前时间，表示已经过期 </span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (currentValueStr != <span class=\"literal\">null</span> &amp;&amp; Long.parseLong(currentValueStr) &lt; System.currentTimeMillis()) &#123; </span><br><span class=\"line\">    <span class=\"comment\">// 锁已过期，获取上一个锁的过期时间，并设置现在锁的过期时间</span></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">oldValueStr</span> <span class=\"operator\">=</span> jedis.getSet(key_resource_id, expiresStr); </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldValueStr != <span class=\"literal\">null</span> &amp;&amp; oldValueStr.equals(currentValueStr)) &#123; </span><br><span class=\"line\">        <span class=\"comment\">// 考虑多线程并发的情况，只有一个线程的设置值和当前值相同，它才可以加锁 </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"comment\">//其他情况，均返回加锁失败 </span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"literal\">false</span>; </span><br></pre></td></tr></table></figure><br />\n 这种方案也有这些缺点：</p>\n<ul>\n<li>过期时间是客户端自己生成的，分布式环境下，每个客户端的时间必须同步。</li>\n<li>没有保存持有者的唯一标识，可能被别的客户端释放 / 解锁。</li>\n<li>锁过期的时候，并发多个客户端同时请求过来，都执行了 jedis.getSet ()，最终只能有一个客户端加锁成功，但是该客户端锁的过期时间，可能被别的客户端覆盖。</li>\n</ul>\n<h2 id=\"set的扩展命令set-ex-px-nx注意可能存在的问题\"><a class=\"anchor\" href=\"#set的扩展命令set-ex-px-nx注意可能存在的问题\">#</a> set 的扩展命令（set ex px nx）（注意可能存在的问题）</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>（jedis.set(key, lock_value, <span class=\"string\">&quot;NX&quot;</span>, <span class=\"string\">&quot;EX&quot;</span>, 100s) == <span class=\"number\">1</span>）&#123; </span><br><span class=\"line\">    <span class=\"comment\">//加锁 </span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123; </span><br><span class=\"line\">        <span class=\"comment\">//业务处理 do something  </span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span>()&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123; </span><br><span class=\"line\">        jedis.del(key); </span><br><span class=\"line\">        <span class=\"comment\">//释放锁 </span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 这个方案可能存在这样的问题：</p>\n<ul>\n<li>锁过期释放了，业务还没执行完。</li>\n<li>锁被别的线程误删。</li>\n</ul>\n<h1 id=\"redission\"><a class=\"anchor\" href=\"#redission\">#</a> Redission</h1>\n<p><strong>分布式锁</strong>可能存在<strong>锁过期释放，业务没执行完的问题</strong>。有些小伙伴认为，稍微把锁过期时间设置长一些就可以啦。其实我们设想一下，是否可以给获得锁的线程，开启一个定时守护线程，每隔一段时间检查锁是否还存在，存在则对锁的过期时间延长，防止锁过期提前释放。</p>\n<p>只要线程一加锁成功，就会启动一个 watch dog 看门狗，它是一个后台线程，会每隔 10 秒检查一下，如果线程 1 还持有锁，那么就会不断的延长锁 key 的生存时间。因此，Redisson 就是使用 Redisson 解决了<strong>锁过期释放，业务没执行完</strong>问题。</p>\n<h1 id=\"红锁redlock\"><a class=\"anchor\" href=\"#红锁redlock\">#</a> 红锁 Redlock</h1>\n<p>Redlock 核心思想是这样的：<br />\n搞多个 Redis master 部署，以保证它们不会同时宕掉。并且这些 master 节点是完全相互独立的，相互之间不存在数据同步。同时，需要确保在这多个 master 实例上，是与在 Redis 单实例，使用相同方法来获取和释放锁。<br />\n简化下步骤就是：</p>\n<ul>\n<li>按顺序向 5 个 master 节点请求加锁</li>\n<li>根据设置的超时时间来判断，是不是要跳过该 master 节点。</li>\n<li>如果大于等于三个节点加锁成功，并且使用的时间小于锁的有效期，即可认定加锁成功啦。</li>\n<li>如果获取锁失败，解锁！</li>\n</ul>\n<h1 id=\"事务机制\"><a class=\"anchor\" href=\"#事务机制\">#</a> 事务机制</h1>\n<p>Redis 通过 MULTI、EXEC、WATCH 等一组命令集合，来实现事务机制。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p>\n<p>简言之，Redis 事务就是顺序性、一次性、排他性的执行一个队列中的一系列命令。</p>\n<p>Redis 执行事务的流程如下：</p>\n<ul>\n<li>开始事务（MULTI）</li>\n<li>命令入队</li>\n<li>执行事务（EXEC）</li>\n<li>撤销事务（DISCARD ）</li>\n</ul>\n",
            "tags": [
                "后端知识",
                "Java",
                "Redis-缓存中间件"
            ]
        },
        {
            "id": "https://lemon-not-cat.github.io/2024/03/31/back-end/java/nacos/nacos/",
            "url": "https://lemon-not-cat.github.io/2024/03/31/back-end/java/nacos/nacos/",
            "title": "nacos",
            "date_published": "2024-03-31T07:26:58.000Z",
            "content_html": "",
            "tags": [
                "后端知识",
                "Java",
                "Nacos-动态服务发现、配置管理和服务管理平台"
            ]
        },
        {
            "id": "https://lemon-not-cat.github.io/2024/03/05/first/",
            "url": "https://lemon-not-cat.github.io/2024/03/05/first/",
            "title": "first",
            "date_published": "2024-03-05T14:26:58.000Z",
            "content_html": "<h1 id=\"hello\"><a class=\"anchor\" href=\"#hello\">#</a> Hello</h1>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String... args)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n",
            "tags": []
        },
        {
            "id": "https://lemon-not-cat.github.io/2024/03/05/hello-world/",
            "url": "https://lemon-not-cat.github.io/2024/03/05/hello-world/",
            "title": "Hello World",
            "date_published": "2024-03-05T14:21:26.275Z",
            "content_html": "<p>Welcome to <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvLw==\">Hexo</span>! This is your very first post. Check <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv\">documentation</span> for more info. If you get any problems when using Hexo, you can find the answer in <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=\">troubleshooting</span> or you can ask me on <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==\">GitHub</span>.</p>\n<h2 id=\"quick-start\"><a class=\"anchor\" href=\"#quick-start\">#</a> Quick Start</h2>\n<h3 id=\"create-a-new-post\"><a class=\"anchor\" href=\"#create-a-new-post\">#</a> Create a new post</h3>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></p>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s\">Writing</span></p>\n<h3 id=\"run-server\"><a class=\"anchor\" href=\"#run-server\">#</a> Run server</h3>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure></p>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=\">Server</span></p>\n<h3 id=\"generate-static-files\"><a class=\"anchor\" href=\"#generate-static-files\">#</a> Generate static files</h3>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure></p>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s\">Generating</span></p>\n<h3 id=\"deploy-to-remote-sites\"><a class=\"anchor\" href=\"#deploy-to-remote-sites\">#</a> Deploy to remote sites</h3>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure></p>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s\">Deployment</span></p>\n",
            "tags": []
        }
    ]
}