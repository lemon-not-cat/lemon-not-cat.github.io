{
    "version": "https://jsonfeed.org/version/1",
    "title": "灵韵流光",
    "subtitle": "犬吠水声中，桃花带露浓。 树深时见鹿，溪午不闻钟。 野竹分青霭，飞泉挂碧峰。 无人知所去，愁倚两三松。",
    "icon": "https://lemon-not-cat.github.io/images/favicon.ico",
    "description": "对Java的探索 & 编程笔记",
    "home_page_url": "https://lemon-not-cat.github.io",
    "items": [
        {
            "id": "https://lemon-not-cat.github.io/2024/04/01/software-testing/test-notes/test-notes/",
            "url": "https://lemon-not-cat.github.io/2024/04/01/software-testing/test-notes/test-notes/",
            "title": "软件测试笔记",
            "date_published": "2024-03-31T16:00:00.000Z",
            "content_html": "<h1 id=\"一-测试的原则\"><a class=\"anchor\" href=\"#一-测试的原则\">#</a> 一、测试的原则</h1>\n<p>对于软件测试应该具有认识或者心态。</p>\n<h2 id=\"完全的测试程序是不可能的\"><a class=\"anchor\" href=\"#完全的测试程序是不可能的\">#</a> 完全的测试程序是不可能的</h2>\n<p>找出所有的软件缺陷，确保软件完美无缺是不可能的：</p>\n<ul>\n<li>输入量太大。</li>\n<li>输出结果太多。</li>\n<li>软件执行路径太多</li>\n<li>软件说明书是主观的。可以说从旁观者来看是缺陷。</li>\n</ul>\n<p>如果觉得某些测试条件是重复的、务必要的，或者为了节省空间，而将其剔除，那么采用的就是不完全测试。</p>\n<h2 id=\"软件测试是有风险的行为\"><a class=\"anchor\" href=\"#软件测试是有风险的行为\">#</a> 软件测试是有风险的行为</h2>\n<p>如果决定不去测试所有的情况，那就是选择了冒险。</p>\n<p>软件测试员要学会一个关键的思想是，如何把数量巨大的可能测试减少到可以控制的范围，以及图和针对分线做出明治的抉择，哪些测试重要，哪些不重要。我们的目标是找到最优的测试量，是测试不多不少。</p>\n<h2 id=\"测试无法显示潜伏的软件缺陷\"><a class=\"anchor\" href=\"#测试无法显示潜伏的软件缺陷\">#</a> 测试无法显示潜伏的软件缺陷</h2>\n<p>软件测试员可以报告软件缺陷存在，却不能报告团建缺陷不存在，你可以继续测试，发现并报告软件缺陷，但是任何情况下都不能保证软件缺陷没有了。唯一的方法是继续测试，可能还会找到一些。</p>\n<h2 id=\"找到的软件缺陷越多就说明软件缺陷越多\"><a class=\"anchor\" href=\"#找到的软件缺陷越多就说明软件缺陷越多\">#</a> 找到的软件缺陷越多，就说明软件缺陷越多</h2>\n<p>通常，软件测试员会在很长时间内找不到软件缺陷。接着找到一个，之后恒快就会接二连三的找到更多。其中的原因：</p>\n<ul>\n<li>程序员也有心情不好的时候。</li>\n<li>程序员往往犯同样的错误。</li>\n<li>某些软件缺陷实乃冰山一角。</li>\n</ul>\n<h2 id=\"杀虫剂怪事\"><a class=\"anchor\" href=\"#杀虫剂怪事\">#</a> 杀虫剂怪事</h2>\n<p>用于描述软件测试越多，其对测试的免疫力越强的现象。但若未更新测试用例，反复执行测试，难以发现新的缺陷。</p>\n<p>为了克服杀虫剂怪事，软件测试元必须不断编写不同的、新的测试程序，对程序的不同部分进行测试，以找出更多的软件缺陷。</p>\n<h2 id=\"并非所有的软件缺陷都要修复\"><a class=\"anchor\" href=\"#并非所有的软件缺陷都要修复\">#</a> 并非所有的软件缺陷都要修复</h2>\n<p>在软件测试中令人沮丧的是，虽然测试员尽了最大的努力，但并非找出的所有的软件缺陷都要修复。不要泄气 —— 这并不意味着软件测试员未达到目的，或者项目小组将发布质量欠佳的产品。</p>\n<p>作为优秀的软件测试员要进行良好的判断，搞清楚在什么情况下追求完美。项目小组要进行取舍，根据风险决定哪些缺陷要修复，哪些不需要修复。</p>\n<h2 id=\"不修复软件缺陷的原因\"><a class=\"anchor\" href=\"#不修复软件缺陷的原因\">#</a> 不修复软件缺陷的原因：</h2>\n<ul>\n<li>没有足够的时间。</li>\n<li>不算真正的软件缺陷。很多情况下，理解错误、测试错误或者说明书变更会把可能的软件缺陷当作功能来对待。</li>\n<li>修复的风险太大。</li>\n<li>不值得修复。不常出现的软件缺陷和不常用功能中出现的软件缺陷是可以放过的。可以躲过和用户有办法防御的软件缺陷通常不用修复。这些都要归结为商业风险决策。</li>\n</ul>\n<h2 id=\"产品说明书没有最终版本\"><a class=\"anchor\" href=\"#产品说明书没有最终版本\">#</a> 产品说明书没有最终版本</h2>\n<p>软件测试员必须要想到产品说明书可能改变。未曾计划测试的功能可能会增加，经过测试并报告软件缺陷的功能有可能 发生变化甚至被删除。</p>\n<p>这些都有可能发生，软件测试员要灵活地制定测试计划和执行测试的技术。</p>\n<h2 id=\"软件测试员在产品小组中不受欢迎\"><a class=\"anchor\" href=\"#软件测试员在产品小组中不受欢迎\">#</a> 软件测试员在产品小组中不受欢迎</h2>\n<p>软件测试员的工作是检查和批评同事的工作，，挑毛病、公布发现的问题。唉。做这项工作不会受到普遍的欢迎的！你准备好了吗？</p>\n<h1 id=\"二-软件测试的术语和定义\"><a class=\"anchor\" href=\"#二-软件测试的术语和定义\">#</a> 二、软件测试的术语和定义</h1>\n<p>软件测试员应该常常澄清小组中使用的术语的含义，最好是在术语定义上取得一致而不是在 “正确性 &quot; 上争论。</p>\n<p>精确和准确<br />\n软件测试员必须知道 精确（precision） 和 准确（accuracy） 之间的区别。</p>\n<p>软件测试要精度和准度很大程度上取决产品是什么，最终取决于开发小组的目标。</p>\n<p>确认和验证<br />\n确认（verification） ：保证软件符合产品说明书的过程。<br />\n验证（validation） ：保证软件满足用户要求的过程。<br />\n注意：绝不假定产品说明书是对的，如果 确认 产品说明书并且需要对最终产品进行 验证 。</p>\n<p>质量和可靠性<br />\n质量（quality） ：“优秀程度” 或者 “同类优越性”。如果说软件产品质量高，就是指它能够满足客户要求。客户会感到该产品性能卓越，优于其他产品。<br />\n可靠性（reliability） ：仅仅是质量的一个方面。<br />\n软件使用者心目中的质量可能包括，功能的多少，在自己旧 PC 机上运行的能力、软件公司的服务电话好不好打以及软件的价格。产品的可靠性或者产品多长时间崩溃的问题也许重要，但常常不被考虑到。</p>\n<p>测试和质量保证（QA）<br />\n软件测试（testing）员：目标是尽可能早地找出软件缺陷，并确保缺陷得以取得修复。<br />\n软件质量保证（Qualiity Assurance，QA）人员：主要职责是创建和执行改进软件开发过程并防止软件缺陷发生的保准和方法。<br />\n最重要的是要了解自己的工作职责，并于开发小组的其他成员交流。</p>\n<h1 id=\"三-黑盒测试与白盒测试\"><a class=\"anchor\" href=\"#三-黑盒测试与白盒测试\">#</a> 三、黑盒测试与白盒测试</h1>\n<h2 id=\"黑盒测试与白盒测试\"><a class=\"anchor\" href=\"#黑盒测试与白盒测试\">#</a> 黑盒测试与白盒测试</h2>\n<p><strong><em>黑盒测试（balck-box testing）</em></strong> ：软件测试员只需要知道软件要做什么 —— 而无法看到盒子里的软件是如何运行的。只需要进行一些输入，就能得到某种输出结果。他不知到软件是如何运行，怎么会这样，只知道程序做了什么。</p>\n<p><strong><em>白盒测试（white-box testing）</em></strong> ：软件测试员可以访问程序员的代码，并通过检查代码的线索来协助测试 —— 可以看到盒子里面。软件测试员根据代码检查结果判断或多或少可能出错的数目，并据此定制测试。</p>\n<p>注意：进行白盒测试要冒一些风险。因为要以适应代码操作来定制测试，所以很容易形成偏见而无法形成客观测试。</p>\n<h2 id=\"静态测试和动态测试\"><a class=\"anchor\" href=\"#静态测试和动态测试\">#</a> 静态测试和动态测试</h2>\n<ul>\n<li>静态测试（static testing） ：是指测试不运行部分 —— 只是检查和审核。</li>\n<li>动态测试（dynamic testing） ：是指通常意义上的测试 —— 使用和运行软件。</li>\n</ul>\n<h2 id=\"静态黑盒测试\"><a class=\"anchor\" href=\"#静态黑盒测试\">#</a> 静态黑盒测试</h2>\n<p>检测产品说明书属于静态黑盒测试。产品说明书是书面文档，而不是可执行程序。因此是静态的。它是利用各种资源而获得的数据 —— 诸如易用性研究、焦点人群、销售收入等建立的。</p>\n<p>注意：无论产品说明书的格式是如何，都可以利用静态黑盒测试技术测试。通过询问软件的设计者和编制者甚至可以测试没有写出来的软件产品说明书。</p>\n<h2 id=\"动态黑盒测试戴上眼罩测试软件\"><a class=\"anchor\" href=\"#动态黑盒测试戴上眼罩测试软件\">#</a> 动态黑盒测试：戴上眼罩测试软件</h2>\n<p>不深入代码细节测试软件的方法称为 动态黑盒测试 。它是动态的，因为程序在运行 —— 软件测试员像用户一样使用它。同时，它是黑盒子，因为测试时不知道程序如何工作 —— 带上了眼罩。动态黑盒测试常常被称为 行为测试 ，因为测试的是软件在使用过程中的实际行为。</p>\n<p>有效的动态测试需要关于软件行为的一些定义 —— 即需求文档或者产品说明书。<br />\n清楚了被测试软件的输入和输出之后，开始定义测试用例。准确评估风险，把无穷尽的可能性减少到可以控制的范围是成功的诀窍。<br />\n<em><strong>测试用例（testing cases）</strong></em> ：是指进行测试时使用特定输入，以及测试软件的过程步骤。<br />\n在没有产品说明书时使用 探索测试 ：了解软件、设计测试、执行测试同时进行。把软件产品当作产品说明书来对待。系统地逐项了解软件的功能、记录软件的执行情况、详细描述功能。</p>\n<h2 id=\"静态白盒测试检查设计和代码\"><a class=\"anchor\" href=\"#静态白盒测试检查设计和代码\">#</a> 静态白盒测试：检查设计和代码</h2>\n<ul>\n<li>静态测试 ：是指测试非运行部分 —— 检查和审查。</li>\n<li>白盒测试 ：或者称为 透明盒测试 ，是指访问代码，能够查看和审计。</li>\n<li>静态白盒测试 ：是指在不执行软件的条件下有条理地仔细审查软件设计、体系结构和代码，从而找出软件缺陷的过程，有时称为 结构化分析 。</li>\n</ul>\n<p>在开发过程初期让测试小组集中精力进行软件设计的审查非常有价值：<br />\n（1）主要原因：尽早发现软件缺陷，以找出动态黑盒测试难以发现或隔离的软件缺陷；<br />\n（2）另一好处：为黑河测试员在接收软件进行测试时设计和应用测试用例提供思路。黑盒测试员可能不必了解代码 的细节，但是通过听审查评论，可以确定有问题或者容易产生软件缺陷的特性范围。</p>\n<h2 id=\"动态白盒测试和调试\"><a class=\"anchor\" href=\"#动态白盒测试和调试\">#</a> 动态白盒测试和调试</h2>\n<p>一定不要不动态白盒测试和调试弄混了。</p>\n<p>动态白盒测试 的目标是寻找软件缺陷， 调试（debugging） 的目标是修复缺陷。然而他们在隔离软件缺陷的位置和原因尚确实存在交叉现象。</p>\n<p>注意：执行这些底层的测试，会用到许多和程序员使用的相同的工具。可能会使用代码级的调试器来单步跟踪程序，观察变量，设置断点，等等。</p>\n",
            "tags": [
                "软件测试",
                "测试笔记"
            ]
        },
        {
            "id": "https://lemon-not-cat.github.io/2024/03/31/back-end/java/redis/redis/",
            "url": "https://lemon-not-cat.github.io/2024/03/31/back-end/java/redis/redis/",
            "title": "redis",
            "date_published": "2024-03-31T07:26:58.000Z",
            "content_html": "<h1 id=\"持久化\"><a class=\"anchor\" href=\"#持久化\">#</a> 持久化</h1>\n<h2 id=\"1-aof\"><a class=\"anchor\" href=\"#1-aof\">#</a> 1、AOF</h2>\n<ul>\n<li>首先根据 redis 里面的内存数据重新构建一个 AOF 文件</li>\n<li>读取 redis 里面的数据，写入到新的 AOF 文件中</li>\n<li>用新的 AOF 文件覆盖掉现有的 AOF 文件</li>\n<li>redis 把重写这个过程放到子进程中去完成，不影响主进程工作</li>\n<li>为了避免子进程在重写过程中主进程的数据发生变化，redis 把主进程的数据变更追加到 AOF 重写缓冲区中，等到 AOF 文件重写完成后，再将 AOF 重写缓冲区里面的数据追加到新的 AOF 文件里面</li>\n</ul>\n<h2 id=\"2-rdb\"><a class=\"anchor\" href=\"#2-rdb\">#</a> 2、RDB</h2>\n<ul>\n<li>首先会生成一个 fork 子进程，fork 子进程共享 redis 主进程中的内存数据，fork 子进程用来进行 RDB 持久化操作。</li>\n<li>fork 子进程将 redis 内存数据写入到 dump.rmb 临时文件中，写入完成后替换掉最终的 dump.rmb 文件，完成一次持久化。</li>\n<li>当 redis 宕机重启后，redis 会读取 dump.rmb 文件，将数据加载到 redis 内存中。</li>\n</ul>\n<p>持久化还有两种方式，手动触发和自动触发</p>\n<ul>\n<li>手动触发只需要执行 save 或 bgsave 命令即可<br />\n save：save 命令执行时，会阻塞 redis 进程，直到持久化完成才可以进行其他操作<br />\n bgsave：bgsave 命令执行时是异步持久化的，会生成一个 fork 子进程，子进程进行持久化，不影响主进程</li>\n<li>自动触发需要在 redis.conf 中配置，通过 save 配置项，配置 RDB 持久化的规则，当满足规则时候，redis 就会自动执行一次持久化操作</li>\n</ul>\n<h1 id=\"缓存击穿-缓存穿透-缓存雪崩\"><a class=\"anchor\" href=\"#缓存击穿-缓存穿透-缓存雪崩\">#</a> 缓存击穿、缓存穿透、缓存雪崩</h1>\n<h2 id=\"缓存击穿\"><a class=\"anchor\" href=\"#缓存击穿\">#</a> 缓存击穿</h2>\n<p><strong>概念</strong>：指热点 key 在某个时间点过期的时候，而恰好在这个时间点对这个 Key 有大量的并发请求过来，从而大量的请求打到 db。<strong>解决方案就有两种：</strong></p>\n<ul>\n<li>使用互斥锁方案。缓存失效时，不是立即去加载 db 数据，而是先使用某些带成功返回的原子操作命令，如 (Redis 的 setnx) 去操作，成功的时候，再去加载 db 数据库数据和设置缓存。否则就去重试获取缓存。</li>\n<li>“永不过期”，是指没有设置过期时间，但是热点数据快要过期时，异步线程去更新和设置过期时间。</li>\n</ul>\n<h2 id=\"缓存穿透\"><a class=\"anchor\" href=\"#缓存穿透\">#</a> 缓存穿透</h2>\n<p><strong>概念</strong> ：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，进而给数据库带来压力。<strong>缓存穿透一般都是这几种情况产生的：</strong></p>\n<ul>\n<li><strong>业务不合理的设计</strong>，比如大多数用户都没开守护，但是你的每个请求都去缓存，查询某个 userid 查询有没有守护。</li>\n<li><strong>业务 / 运维 / 开发失误的操作</strong>，比如缓存和数据库的数据都被误删除了。</li>\n<li><strong>黑客非法请求攻击</strong>，比如黑客故意捏造大量非法请求，以读取不存在的业务数据。</li>\n</ul>\n<p><strong>如何避免缓存穿透呢？</strong></p>\n<ul>\n<li>如果是非法请求，我们在 API 入口，对参数进行校验，过滤非法值。</li>\n<li>如果查询数据库为空，我们可以给缓存设置个空值，或者默认值。但是如有有写请求进来的话，需要更新缓存哈，以保证缓存一致性，同时，最后给缓存设置适当的过期时间。（业务上比较常用，简单有效）</li>\n<li>使用布隆过滤器快速判断数据是否存在。即一个查询请求过来时，先通过布隆过滤器判断值是否存在，存在才继续往下查。</li>\n</ul>\n<h2 id=\"缓存雪崩\"><a class=\"anchor\" href=\"#缓存雪崩\">#</a> 缓存雪崩</h2>\n<p><strong>概念</strong>：指缓存中数据大批量到过期时间，而查询数据量巨大，请求都直接访问数据库，引起数据库压力过大甚至 down 机。<strong>解决方案</strong>：</p>\n<ul>\n<li>缓存雪奔一般是由于大量数据同时过期造成的，对于这个原因，可通过均匀设置过期时间解决，即让过期时间相对离散一点。如采用一个较大固定值 + 一个较小的随机值，5 小时 + 0 到 1800 秒酱紫。</li>\n<li>Redis 故障宕机也可能引起缓存雪奔。这就需要构造 Redis 高可用集群啦。</li>\n</ul>\n<h1 id=\"过期策略\"><a class=\"anchor\" href=\"#过期策略\">#</a> 过期策略</h1>\n<p>我们在 set key 的时候，可以给它设置一个过期时间，比如 expire key 60。指定这 key60s 后过期，60s 后，redis 是如何处理的嘛？我们先来介绍几种过期策略：</p>\n<p>定时过期<br />\n每个设置过期时间的 key 都需要创建一个定时器，到过期时间就会立即对 key 进行清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的 CPU 资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</p>\n<p>惰性过期<br />\n只有当访问一个 key 时，才会判断该 key 是否已过期，过期则清除。该策略可以最大化地节省 CPU 资源，却对内存非常不友好。极端情况可能出现大量的过期 key 没有再次被访问，从而不会被清除，占用大量内存。</p>\n<p>定期过期<br />\n每隔一定的时间，会扫描一定数量的数据库的 expires 字典中一定数量的 key，并清除其中已过期的 key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得 CPU 和内存资源达到最优的平衡效果。expires 字典会保存所有设置了过期时间的 key 的过期时间数据，其中，key 是指向键空间中的某个键的指针，value 是该键的毫秒精度的 UNIX 时间戳表示的过期时间。键空间是指该 Redis 集群中保存的所有键。</p>\n<p>Redis 中同时使用了惰性过期和定期过期两种过期策略：</p>\n<ul>\n<li>假设 Redis 当前存放 30 万个 key，并且都设置了过期时间，如果你每隔 100ms 就去检查这全部的 key，CPU 负载会特别高，最后可能会挂掉。</li>\n<li>因此，redis 采取的是定期过期，每隔 100ms 就随机抽取一定数量的 key 来检查和删除的。</li>\n<li>但是呢，最后可能会有很多已经过期的 key 没被删除。这时候，redis 采用惰性删除。在你获取某个 key 的时候，redis 会检查一下，这个 key 如果设置了过期时间并且已经过期了，此时就会删除。</li>\n</ul>\n<h1 id=\"内存淘汰策略\"><a class=\"anchor\" href=\"#内存淘汰策略\">#</a> 内存淘汰策略</h1>\n<ul>\n<li>volatile-lru：当内存不足以容纳新写入数据时，从设置了过期时间的 key 中使用 LRU（最近最少使用）算法进行淘汰；</li>\n<li>allkeys-lru：当内存不足以容纳新写入数据时，从所有 key 中使用 LRU（最近最少使用）算法进行淘汰。</li>\n<li>volatile-lfu：4.0 版本新增，当内存不足以容纳新写入数据时，在过期的 key 中，使用 LFU 算法进行删除 key。</li>\n<li>allkeys-lfu：4.0 版本新增，当内存不足以容纳新写入数据时，从所有 key 中使用 LFU 算法进行淘汰；</li>\n<li>volatile-random：当内存不足以容纳新写入数据时，从设置了过期时间的 key 中，随机淘汰数据；。</li>\n<li>allkeys-random：当内存不足以容纳新写入数据时，从所有 key 中随机淘汰数据。</li>\n<li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的 key 中，根据过期时间进行淘汰，越早过期的优先被淘汰；</li>\n<li>noeviction：默认策略，当内存不足以容纳新写入数据时，新写入操作会报错。</li>\n</ul>\n<h1 id=\"主从模式\"><a class=\"anchor\" href=\"#主从模式\">#</a> 主从模式</h1>\n<p>主从模式中，Redis 部署了多台机器，有主节点，负责读写操作，有从节点，只负责读操作。从节点的数据来自主节点，实现原理就是<strong>主从复制机制</strong><br />\n主从复制包括全量复制，增量复制两种。一般当 slave 第一次启动连接 master，或者认为是第一次连接，就采用<strong>全量复制</strong> slave 与 master 全量同步之后，master 上的数据，如果再次发生更新，就会触发<strong>增量复制</strong>。</p>\n<p>当 master 节点发生数据增减时，就会触发 replicationFeedSalves () 函数，接下来在 Master 节点上调用的每一个命令会使用 replicationFeedSlaves () 来同步到 Slave 节点。执行此函数之前呢，master 节点会判断用户执行的命令是否有数据更新，如果有数据更新的话，并且 slave 节点不为空，就会执行此函数。这个函数作用就是：<em><strong>把用户执行的命令发送到所有的 slave 节点，让 slave 节点执行。</strong></em></p>\n<h1 id=\"哨兵模式\"><a class=\"anchor\" href=\"#哨兵模式\">#</a> 哨兵模式</h1>\n<p>主从模式中，一旦主节点由于故障不能提供服务，需要人工将从节点晋升为主节点，同时还要通知应用方更新主节点地址。显然，多数业务场景都不能接受这种故障处理方式。Redis 从 2.8 开始正式提供了 Redis Sentinel（哨兵）架构来解决这个问题。</p>\n<p>哨兵模式，由一个或多个 Sentinel 实例组成的 Sentinel 系统，它可以监视所有的 Redis 主节点和从节点，并在被监视的主节点进入下线状态时，自动将下线主服务器属下的某个从节点升级为新的主节点。但是呢，一个哨兵进程对 Redis 节点进行监控，就可能会出现问题（单点问题），因此，可以使用多个哨兵来进行监控 Redis 节点，并且各个哨兵之间还会进行监控。</p>\n<p>简单来说，哨兵模式就三个作用：</p>\n<ul>\n<li>发送命令，等待 Redis 服务器（包括主服务器和从服务器）返回监控其运行状态；</li>\n<li>哨兵监测到主节点宕机，会自动将从节点切换成主节点，然后通过发布订阅模式通知其他的从节点，修改配置文件，让它们切换主机；</li>\n<li>哨兵之间还会相互监控，从而达到高可用。</li>\n</ul>\n<p>故障切换的过程是怎样的呢<br />\n假设主服务器宕机，哨兵 1 先检测到这个结果，系统并不会马上进行 failover 过程，仅仅是哨兵 1 主观的认为主服务器不可用，这个现象成为主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行 failover 操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线。这样对于客户端而言，一切都是透明的。</p>\n<p>哨兵的工作模式如下：</p>\n<ul>\n<li>每个 Sentinel 以每秒钟一次的频率向它所知的 Master，Slave 以及其他 Sentinel 实例发送一个 PING 命令。</li>\n<li>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel 标记为主观下线。</li>\n<li>如果一个 Master 被标记为主观下线，则正在监视这个 Master 的所有 Sentinel 要以每秒一次的频率确认 Master 的确进入了主观下线状态。</li>\n<li>当有足够数量的 Sentinel（大于等于配置文件指定的值）在指定的时间范围内确认 Master 的确进入了主观下线状态， 则 Master 会被标记为客观下线。</li>\n<li>在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率向它已知的所有 Master，Slave 发送 INFO 命令。</li>\n<li>当 Master 被 Sentinel 标记为客观下线时，Sentinel 向下线的 Master 的所有 Slave 发送 INFO 命令的频率会从 10 秒一次改为每秒一次</li>\n<li>若没有足够数量的 Sentinel 同意 Master 已经下线， Master 的客观下线状态就会被移除；若 Master 重新向 Sentinel 的 PING 命令返回有效回复， Master 的主观下线状态就会被移除。</li>\n</ul>\n<h1 id=\"cluster集群模式\"><a class=\"anchor\" href=\"#cluster集群模式\">#</a> Cluster 集群模式</h1>\n<p>哨兵模式基于主从模式，实现读写分离，它还可以自动切换，系统可用性更高。但是它每个节点存储的数据是一样的，浪费内存，并且不好在线扩容。因此，Cluster 集群应运而生，它在 Redis3.0 加入的，实现了 Redis 的分布式存储。对数据进行分片，也就是说每台 Redis 节点上存储不同的内容，来解决在线扩容的问题。并且，它也提供复制和故障转移的功能。</p>\n<p>一个 Redis 集群由多个节点组成，各个节点之间是怎么通信的呢？通过 Gossip 协议！<br />\nRedis Cluster 集群通过 Gossip 协议进行通信，节点之前不断交换信息，交换的信息内容包括节点出现故障、新节点加入、主从节点变更信息、slot 信息等等。常用的 Gossip 消息分为 4 种，分别是：ping、pong、meet、fail。</p>\n<ul>\n<li>meet 消息：通知新节点加入。消息发送者通知接收者加入到当前集群，meet 消息通信正常完成后，接收节点会加入到集群中并进行周期性的 ping、pong 消息交换。</li>\n<li>ping 消息：集群内交换最频繁的消息，集群内每个节点每秒向多个其他节点发送 ping 消息，用于检测节点是否在线和交换彼此状态信息。</li>\n<li>pong 消息：当接收到 ping、meet 消息时，作为响应消息回复给发送方确认消息正常通信。pong 消息内部封装了自身状态数据。节点也可以向集群内广播自身的 pong 消息来通知整个集群对自身状态进行更新。</li>\n<li>fail 消息：当节点判定集群内另一个节点下线时，会向集群内广播一个 fail 消息，其他节点接收到 fail 消息之后把对应节点更新为下线状态。</li>\n</ul>\n<p>特别的，每个节点是通过<strong>集群总线 (cluster bus)</strong> 与其他的节点进行通信的。通讯时，使用特殊的端口号，即对外服务端口号加 10000。例如如果某个 node 的端口号是 6379，那么它与其它 nodes 通信的端口号是 16379。nodes 之间的通信采用特殊的二进制协议。</p>\n<p>Hash Slot 插槽算法<br />\n既然是分布式存储，Cluster 集群使用的分布式算法是一致性 Hash 嘛？并不是，而是 Hash Slot 插槽算法。<br />\n插槽算法把整个数据库被分为 16384 个 slot（槽），每个进入 Redis 的键值对，根据 key 进行散列，分配到这 16384 插槽中的一个。使用的哈希映射也比较简单，用 CRC16 算法计算出一个 16 位的值，再对 16384 取模。数据库中的每个键都属于这 16384 个槽的其中一个，集群中的每个节点都可以处理这 16384 个槽。<br />\n集群中的每个节点负责一部分的 hash 槽，比如当前集群有 A、B、C 个节点，每个节点上的哈希槽数 =16384/3，那么就有：</p>\n<ul>\n<li>节点 A 负责 0~5460 号哈希槽</li>\n<li>节点 B 负责 5461~10922 号哈希槽</li>\n<li>节点 C 负责 10923~16383 号哈希槽</li>\n</ul>\n<p>Redis Cluster 集群中，需要确保 16384 个槽对应的 node 都正常工作，如果某个 node 出现故障，它负责的 slot 也会失效，整个集群将不能工作。<br />\n因此为了保证高可用，Cluster 集群引入了主从复制，一个主节点对应一个或者多个从节点。当其它主节点 ping 一个主节点 A 时，如果半数以上的主节点与 A 通信超时，那么认为主节点 A 宕机了。如果主节点宕机时，就会启用从节点。<br />\n在 Redis 的每一个节点上，都有两个玩意，一个是插槽（slot），它的取值范围是 0~16383。另外一个是 cluster，可以理解为一个集群管理的插件。当我们存取的 key 到达时，Redis 会根据 CRC16 算法得出一个 16 bit 的值，然后把结果对 16384 取模。酱紫每个 key 都会对应一个编号在 0~16383 之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作。<br />\n虽然数据是分开存储在不同节点上的，但是对客户端来说，整个集群 Cluster，被看做一个整体。客户端端连接任意一个 node，看起来跟操作单实例的 Redis 一样。当客户端操作的 key 没有被分配到正确的 node 节点时，Redis 会返回转向指令，最后指向正确的 node，这就有点像浏览器页面的 302 重定向跳转。</p>\n<p>故障转移<br />\n Redis 集群实现了高可用，当集群内节点出现故障时，通过故障转移，以保证集群正常对外提供服务。<br />\nredis 集群通过 ping/pong 消息，实现故障发现。这个环境包括主观下线和客观下线。<br />\n主观下线： 某个节点认为另一个节点不可用，即下线状态，这个状态并不是最终的故障判定，只能代表一个节点的意见，可能存在误判情况。</p>\n<p>主观下线<br />\n客观下线： 指标记一个节点真正的下线，集群内多个节点都认为该节点不可用，从而达成共识的结果。如果是持有槽的主节点故障，需要为该节点进行故障转移。<br />\n假如节点 A 标记节点 B 为主观下线，一段时间后，节点 A 通过消息把节点 B 的状态发到其它节点，当节点 C 接受到消息并解析出消息体时，如果发现节点 B 的 pfail 状态时，会触发客观下线流程；<br />\n当下线为主节点时，此时 Redis Cluster 集群为统计持有槽的主节点投票，看投票数是否达到一半，当下线报告统计数大于一半时，被标记为客观下线状态。</p>\n<p>客观下线<strong>故障恢复</strong>：故障发现后，如果下线节点的是主节点，则需要在它的从节点中选一个替换它，以保证集群的高可用。流程如下：</p>\n<ul>\n<li>资格检查：检查从节点是否具备替换故障主节点的条件。</li>\n<li>准备选举时间：资格检查通过后，更新触发故障选举时间。</li>\n<li>发起选举：到了故障选举时间，进行选举。</li>\n<li>选举投票：只有持有槽的<strong>主节点</strong>才有票，从节点收集到足够的选票（大于一半），触发<strong>替换主节点操作</strong></li>\n</ul>\n<h1 id=\"分布式锁\"><a class=\"anchor\" href=\"#分布式锁\">#</a> 分布式锁</h1>\n<p><strong>分布式锁</strong>，是控制分布式系统不同进程共同访问共享资源的一种锁的实现。秒杀下单、抢红包等等业务场景，都需要用到分布式锁，我们项目中经常使用 Redis 作为分布式锁。</p>\n<h2 id=\"命令setnx-expire分开写\"><a class=\"anchor\" href=\"#命令setnx-expire分开写\">#</a> 命令 setnx + expire 分开写</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>（jedis.setnx(key,lock_value) == <span class=\"number\">1</span>）&#123; </span><br><span class=\"line\">    <span class=\"comment\">//加锁 expire（key，100）; </span></span><br><span class=\"line\">    <span class=\"comment\">//设置过期时间 </span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123; </span><br><span class=\"line\">        <span class=\"comment\">//业务请求 do something </span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span>()&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123; </span><br><span class=\"line\">        jedis.del(key); </span><br><span class=\"line\">        <span class=\"comment\">//释放锁 </span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 如果执行完 setnx 加锁，正要执行 expire 设置过期时间时，进程 crash 掉或者要重启维护了，那这个锁就 “长生不老” 了，别的线程永远获取不到锁啦，所以分布式锁不能这么实现。</p>\n<h2 id=\"setnx-value值是过期时间\"><a class=\"anchor\" href=\"#setnx-value值是过期时间\">#</a> setnx + value 值是过期时间</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">expires</span> <span class=\"operator\">=</span> System.currentTimeMillis() + expireTime; </span><br><span class=\"line\"><span class=\"comment\">//系统时间+设置的过期时间 </span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">expiresStr</span> <span class=\"operator\">=</span> String.valueOf(expires); </span><br><span class=\"line\"><span class=\"comment\">// 如果当前锁不存在，返回加锁成功 </span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (jedis.setnx(key, expiresStr) == <span class=\"number\">1</span>) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"comment\">// 如果锁已经存在，获取锁的过期时间 </span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">currentValueStr</span> <span class=\"operator\">=</span> jedis.get(key); </span><br><span class=\"line\"><span class=\"comment\">// 如果获取到的过期时间，小于系统当前时间，表示已经过期 </span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (currentValueStr != <span class=\"literal\">null</span> &amp;&amp; Long.parseLong(currentValueStr) &lt; System.currentTimeMillis()) &#123; </span><br><span class=\"line\">    <span class=\"comment\">// 锁已过期，获取上一个锁的过期时间，并设置现在锁的过期时间</span></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">oldValueStr</span> <span class=\"operator\">=</span> jedis.getSet(key_resource_id, expiresStr); </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldValueStr != <span class=\"literal\">null</span> &amp;&amp; oldValueStr.equals(currentValueStr)) &#123; </span><br><span class=\"line\">        <span class=\"comment\">// 考虑多线程并发的情况，只有一个线程的设置值和当前值相同，它才可以加锁 </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"comment\">//其他情况，均返回加锁失败 </span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"literal\">false</span>; </span><br></pre></td></tr></table></figure><br />\n 这种方案也有这些缺点：</p>\n<ul>\n<li>过期时间是客户端自己生成的，分布式环境下，每个客户端的时间必须同步。</li>\n<li>没有保存持有者的唯一标识，可能被别的客户端释放 / 解锁。</li>\n<li>锁过期的时候，并发多个客户端同时请求过来，都执行了 jedis.getSet ()，最终只能有一个客户端加锁成功，但是该客户端锁的过期时间，可能被别的客户端覆盖。</li>\n</ul>\n<h2 id=\"set的扩展命令set-ex-px-nx注意可能存在的问题\"><a class=\"anchor\" href=\"#set的扩展命令set-ex-px-nx注意可能存在的问题\">#</a> set 的扩展命令（set ex px nx）（注意可能存在的问题）</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>（jedis.set(key, lock_value, <span class=\"string\">&quot;NX&quot;</span>, <span class=\"string\">&quot;EX&quot;</span>, 100s) == <span class=\"number\">1</span>）&#123; </span><br><span class=\"line\">    <span class=\"comment\">//加锁 </span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123; </span><br><span class=\"line\">        <span class=\"comment\">//业务处理 do something  </span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span>()&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123; </span><br><span class=\"line\">        jedis.del(key); </span><br><span class=\"line\">        <span class=\"comment\">//释放锁 </span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 这个方案可能存在这样的问题：</p>\n<ul>\n<li>锁过期释放了，业务还没执行完。</li>\n<li>锁被别的线程误删。</li>\n</ul>\n<h1 id=\"redission\"><a class=\"anchor\" href=\"#redission\">#</a> Redission</h1>\n<p><strong>分布式锁</strong>可能存在<strong>锁过期释放，业务没执行完的问题</strong>。有些小伙伴认为，稍微把锁过期时间设置长一些就可以啦。其实我们设想一下，是否可以给获得锁的线程，开启一个定时守护线程，每隔一段时间检查锁是否还存在，存在则对锁的过期时间延长，防止锁过期提前释放。</p>\n<p>只要线程一加锁成功，就会启动一个 watch dog 看门狗，它是一个后台线程，会每隔 10 秒检查一下，如果线程 1 还持有锁，那么就会不断的延长锁 key 的生存时间。因此，Redisson 就是使用 Redisson 解决了<strong>锁过期释放，业务没执行完</strong>问题。</p>\n<h1 id=\"红锁redlock\"><a class=\"anchor\" href=\"#红锁redlock\">#</a> 红锁 Redlock</h1>\n<p>Redlock 核心思想是这样的：<br />\n搞多个 Redis master 部署，以保证它们不会同时宕掉。并且这些 master 节点是完全相互独立的，相互之间不存在数据同步。同时，需要确保在这多个 master 实例上，是与在 Redis 单实例，使用相同方法来获取和释放锁。<br />\n简化下步骤就是：</p>\n<ul>\n<li>按顺序向 5 个 master 节点请求加锁</li>\n<li>根据设置的超时时间来判断，是不是要跳过该 master 节点。</li>\n<li>如果大于等于三个节点加锁成功，并且使用的时间小于锁的有效期，即可认定加锁成功啦。</li>\n<li>如果获取锁失败，解锁！</li>\n</ul>\n<h1 id=\"事务机制\"><a class=\"anchor\" href=\"#事务机制\">#</a> 事务机制</h1>\n<p>Redis 通过 MULTI、EXEC、WATCH 等一组命令集合，来实现事务机制。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p>\n<p>简言之，Redis 事务就是顺序性、一次性、排他性的执行一个队列中的一系列命令。</p>\n<p>Redis 执行事务的流程如下：</p>\n<ul>\n<li>开始事务（MULTI）</li>\n<li>命令入队</li>\n<li>执行事务（EXEC）</li>\n<li>撤销事务（DISCARD ）</li>\n</ul>\n",
            "tags": [
                "后端知识",
                "Java",
                "Redis-缓存中间件"
            ]
        },
        {
            "id": "https://lemon-not-cat.github.io/2024/03/31/back-end/java/nacos/nacos/",
            "url": "https://lemon-not-cat.github.io/2024/03/31/back-end/java/nacos/nacos/",
            "title": "nacos",
            "date_published": "2024-03-31T07:26:58.000Z",
            "content_html": "",
            "tags": [
                "后端知识",
                "Java",
                "Nacos-动态服务发现、配置管理和服务管理平台"
            ]
        },
        {
            "id": "https://lemon-not-cat.github.io/2024/03/05/first/",
            "url": "https://lemon-not-cat.github.io/2024/03/05/first/",
            "title": "first",
            "date_published": "2024-03-05T14:26:58.000Z",
            "content_html": "<h1 id=\"hello\"><a class=\"anchor\" href=\"#hello\">#</a> Hello</h1>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String... args)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n",
            "tags": []
        },
        {
            "id": "https://lemon-not-cat.github.io/2024/03/05/hello-world/",
            "url": "https://lemon-not-cat.github.io/2024/03/05/hello-world/",
            "title": "Hello World",
            "date_published": "2024-03-05T14:21:26.275Z",
            "content_html": "<p>Welcome to <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvLw==\">Hexo</span>! This is your very first post. Check <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv\">documentation</span> for more info. If you get any problems when using Hexo, you can find the answer in <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=\">troubleshooting</span> or you can ask me on <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==\">GitHub</span>.</p>\n<h2 id=\"quick-start\"><a class=\"anchor\" href=\"#quick-start\">#</a> Quick Start</h2>\n<h3 id=\"create-a-new-post\"><a class=\"anchor\" href=\"#create-a-new-post\">#</a> Create a new post</h3>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></p>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s\">Writing</span></p>\n<h3 id=\"run-server\"><a class=\"anchor\" href=\"#run-server\">#</a> Run server</h3>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure></p>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=\">Server</span></p>\n<h3 id=\"generate-static-files\"><a class=\"anchor\" href=\"#generate-static-files\">#</a> Generate static files</h3>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure></p>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s\">Generating</span></p>\n<h3 id=\"deploy-to-remote-sites\"><a class=\"anchor\" href=\"#deploy-to-remote-sites\">#</a> Deploy to remote sites</h3>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure></p>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s\">Deployment</span></p>\n",
            "tags": []
        }
    ]
}