<!-- build time:Sat May 11 2024 17:04:40 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="灵韵流光" href="https://lemon-not-cat.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="灵韵流光" href="https://lemon-not-cat.github.io/atom.xml"><link rel="alternate" type="application/json" title="灵韵流光" href="https://lemon-not-cat.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="https://lemon-not-cat.github.io/2024/03/31/redis/redis/"><title>redis - Redis-缓存中间件 | Yume Kousatsu = 灵韵流光 = 犬吠水声中，桃花带露浓。 树深时见鹿，溪午不闻钟。 野竹分青霭，飞泉挂碧峰。 无人知所去，愁倚两三松。</title><meta name="generator" content="Hexo 7.1.1"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">redis</h1><div class="meta"><span class="item" title="创建时间：2024-03-31 15:26:58"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2024-03-31T15:26:58+08:00">2024-03-31</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>8.6k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>8 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Yume Kousatsu</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://s2.loli.net/2024/03/31/TQrqXlFVnkwBdeg.png"></li><li class="item" data-background-image="https://s2.loli.net/2024/04/14/3NAFgjtR54c8fzi.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2024/03/31/DHfNuYgx5mlthvn.png"></li><li class="item" data-background-image="https://s2.loli.net/2024/03/31/MHhef7sYSqBwGix.png"></li><li class="item" data-background-image="https://s2.loli.net/2024/03/29/tGj3z9LNJipWO1g.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2024/03/29/B6iavLZCgHne3kY.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/redis/" itemprop="item" rel="index" title="分类于 Redis-缓存中间件"><span itemprop="name">Redis-缓存中间件</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://lemon-not-cat.github.io/2024/03/31/redis/redis/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="lemon不是猫"><meta itemprop="description" content="犬吠水声中，桃花带露浓。 树深时见鹿，溪午不闻钟。 野竹分青霭，飞泉挂碧峰。 无人知所去，愁倚两三松。, 对Java的探索 & 编程笔记"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="灵韵流光"></span><div class="body md" itemprop="articleBody"><h1 id="持久化"><a class="anchor" href="#持久化">#</a> 持久化</h1><h2 id="1-aof"><a class="anchor" href="#1-aof">#</a> 1、AOF</h2><ul><li>首先根据 redis 里面的内存数据重新构建一个 AOF 文件</li><li>读取 redis 里面的数据，写入到新的 AOF 文件中</li><li>用新的 AOF 文件覆盖掉现有的 AOF 文件</li><li>redis 把重写这个过程放到子进程中去完成，不影响主进程工作</li><li>为了避免子进程在重写过程中主进程的数据发生变化，redis 把主进程的数据变更追加到 AOF 重写缓冲区中，等到 AOF 文件重写完成后，再将 AOF 重写缓冲区里面的数据追加到新的 AOF 文件里面</li></ul><h2 id="2-rdb"><a class="anchor" href="#2-rdb">#</a> 2、RDB</h2><ul><li>首先会生成一个 fork 子进程，fork 子进程共享 redis 主进程中的内存数据，fork 子进程用来进行 RDB 持久化操作。</li><li>fork 子进程将 redis 内存数据写入到 dump.rmb 临时文件中，写入完成后替换掉最终的 dump.rmb 文件，完成一次持久化。</li><li>当 redis 宕机重启后，redis 会读取 dump.rmb 文件，将数据加载到 redis 内存中。</li></ul><p>持久化还有两种方式，手动触发和自动触发</p><ul><li>手动触发只需要执行 save 或 bgsave 命令即可<br>save：save 命令执行时，会阻塞 redis 进程，直到持久化完成才可以进行其他操作<br>bgsave：bgsave 命令执行时是异步持久化的，会生成一个 fork 子进程，子进程进行持久化，不影响主进程</li><li>自动触发需要在 redis.conf 中配置，通过 save 配置项，配置 RDB 持久化的规则，当满足规则时候，redis 就会自动执行一次持久化操作</li></ul><h1 id="缓存击穿-缓存穿透-缓存雪崩"><a class="anchor" href="#缓存击穿-缓存穿透-缓存雪崩">#</a> 缓存击穿、缓存穿透、缓存雪崩</h1><h2 id="缓存击穿"><a class="anchor" href="#缓存击穿">#</a> 缓存击穿</h2><p><strong>概念</strong>：指热点 key 在某个时间点过期的时候，而恰好在这个时间点对这个 Key 有大量的并发请求过来，从而大量的请求打到 db。<strong>解决方案就有两种：</strong></p><ul><li>使用互斥锁方案。缓存失效时，不是立即去加载 db 数据，而是先使用某些带成功返回的原子操作命令，如 (Redis 的 setnx) 去操作，成功的时候，再去加载 db 数据库数据和设置缓存。否则就去重试获取缓存。</li><li>“永不过期”，是指没有设置过期时间，但是热点数据快要过期时，异步线程去更新和设置过期时间。</li></ul><h2 id="缓存穿透"><a class="anchor" href="#缓存穿透">#</a> 缓存穿透</h2><p><strong>概念</strong> ：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，进而给数据库带来压力。<strong>缓存穿透一般都是这几种情况产生的：</strong></p><ul><li><strong>业务不合理的设计</strong>，比如大多数用户都没开守护，但是你的每个请求都去缓存，查询某个 userid 查询有没有守护。</li><li><strong>业务 / 运维 / 开发失误的操作</strong>，比如缓存和数据库的数据都被误删除了。</li><li><strong>黑客非法请求攻击</strong>，比如黑客故意捏造大量非法请求，以读取不存在的业务数据。</li></ul><p><strong>如何避免缓存穿透呢？</strong></p><ul><li>如果是非法请求，我们在 API 入口，对参数进行校验，过滤非法值。</li><li>如果查询数据库为空，我们可以给缓存设置个空值，或者默认值。但是如有有写请求进来的话，需要更新缓存哈，以保证缓存一致性，同时，最后给缓存设置适当的过期时间。（业务上比较常用，简单有效）</li><li>使用布隆过滤器快速判断数据是否存在。即一个查询请求过来时，先通过布隆过滤器判断值是否存在，存在才继续往下查。</li></ul><h2 id="缓存雪崩"><a class="anchor" href="#缓存雪崩">#</a> 缓存雪崩</h2><p><strong>概念</strong>：指缓存中数据大批量到过期时间，而查询数据量巨大，请求都直接访问数据库，引起数据库压力过大甚至 down 机。<strong>解决方案</strong>：</p><ul><li>缓存雪奔一般是由于大量数据同时过期造成的，对于这个原因，可通过均匀设置过期时间解决，即让过期时间相对离散一点。如采用一个较大固定值 + 一个较小的随机值，5 小时 + 0 到 1800 秒酱紫。</li><li>Redis 故障宕机也可能引起缓存雪奔。这就需要构造 Redis 高可用集群啦。</li></ul><h1 id="过期策略"><a class="anchor" href="#过期策略">#</a> 过期策略</h1><p>我们在 set key 的时候，可以给它设置一个过期时间，比如 expire key 60。指定这 key60s 后过期，60s 后，redis 是如何处理的嘛？我们先来介绍几种过期策略：</p><p>定时过期<br>每个设置过期时间的 key 都需要创建一个定时器，到过期时间就会立即对 key 进行清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的 CPU 资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</p><p>惰性过期<br>只有当访问一个 key 时，才会判断该 key 是否已过期，过期则清除。该策略可以最大化地节省 CPU 资源，却对内存非常不友好。极端情况可能出现大量的过期 key 没有再次被访问，从而不会被清除，占用大量内存。</p><p>定期过期<br>每隔一定的时间，会扫描一定数量的数据库的 expires 字典中一定数量的 key，并清除其中已过期的 key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得 CPU 和内存资源达到最优的平衡效果。expires 字典会保存所有设置了过期时间的 key 的过期时间数据，其中，key 是指向键空间中的某个键的指针，value 是该键的毫秒精度的 UNIX 时间戳表示的过期时间。键空间是指该 Redis 集群中保存的所有键。</p><p>Redis 中同时使用了惰性过期和定期过期两种过期策略：</p><ul><li>假设 Redis 当前存放 30 万个 key，并且都设置了过期时间，如果你每隔 100ms 就去检查这全部的 key，CPU 负载会特别高，最后可能会挂掉。</li><li>因此，redis 采取的是定期过期，每隔 100ms 就随机抽取一定数量的 key 来检查和删除的。</li><li>但是呢，最后可能会有很多已经过期的 key 没被删除。这时候，redis 采用惰性删除。在你获取某个 key 的时候，redis 会检查一下，这个 key 如果设置了过期时间并且已经过期了，此时就会删除。</li></ul><h1 id="内存淘汰策略"><a class="anchor" href="#内存淘汰策略">#</a> 内存淘汰策略</h1><ul><li>volatile-lru：当内存不足以容纳新写入数据时，从设置了过期时间的 key 中使用 LRU（最近最少使用）算法进行淘汰；</li><li>allkeys-lru：当内存不足以容纳新写入数据时，从所有 key 中使用 LRU（最近最少使用）算法进行淘汰。</li><li>volatile-lfu：4.0 版本新增，当内存不足以容纳新写入数据时，在过期的 key 中，使用 LFU 算法进行删除 key。</li><li>allkeys-lfu：4.0 版本新增，当内存不足以容纳新写入数据时，从所有 key 中使用 LFU 算法进行淘汰；</li><li>volatile-random：当内存不足以容纳新写入数据时，从设置了过期时间的 key 中，随机淘汰数据；。</li><li>allkeys-random：当内存不足以容纳新写入数据时，从所有 key 中随机淘汰数据。</li><li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的 key 中，根据过期时间进行淘汰，越早过期的优先被淘汰；</li><li>noeviction：默认策略，当内存不足以容纳新写入数据时，新写入操作会报错。</li></ul><h1 id="主从模式"><a class="anchor" href="#主从模式">#</a> 主从模式</h1><p>主从模式中，Redis 部署了多台机器，有主节点，负责读写操作，有从节点，只负责读操作。从节点的数据来自主节点，实现原理就是<strong>主从复制机制</strong><br>主从复制包括全量复制，增量复制两种。一般当 slave 第一次启动连接 master，或者认为是第一次连接，就采用<strong>全量复制</strong> slave 与 master 全量同步之后，master 上的数据，如果再次发生更新，就会触发<strong>增量复制</strong>。</p><p>当 master 节点发生数据增减时，就会触发 replicationFeedSalves () 函数，接下来在 Master 节点上调用的每一个命令会使用 replicationFeedSlaves () 来同步到 Slave 节点。执行此函数之前呢，master 节点会判断用户执行的命令是否有数据更新，如果有数据更新的话，并且 slave 节点不为空，就会执行此函数。这个函数作用就是：<em><strong>把用户执行的命令发送到所有的 slave 节点，让 slave 节点执行。</strong></em></p><h1 id="哨兵模式"><a class="anchor" href="#哨兵模式">#</a> 哨兵模式</h1><p>主从模式中，一旦主节点由于故障不能提供服务，需要人工将从节点晋升为主节点，同时还要通知应用方更新主节点地址。显然，多数业务场景都不能接受这种故障处理方式。Redis 从 2.8 开始正式提供了 Redis Sentinel（哨兵）架构来解决这个问题。</p><p>哨兵模式，由一个或多个 Sentinel 实例组成的 Sentinel 系统，它可以监视所有的 Redis 主节点和从节点，并在被监视的主节点进入下线状态时，自动将下线主服务器属下的某个从节点升级为新的主节点。但是呢，一个哨兵进程对 Redis 节点进行监控，就可能会出现问题（单点问题），因此，可以使用多个哨兵来进行监控 Redis 节点，并且各个哨兵之间还会进行监控。</p><p>简单来说，哨兵模式就三个作用：</p><ul><li>发送命令，等待 Redis 服务器（包括主服务器和从服务器）返回监控其运行状态；</li><li>哨兵监测到主节点宕机，会自动将从节点切换成主节点，然后通过发布订阅模式通知其他的从节点，修改配置文件，让它们切换主机；</li><li>哨兵之间还会相互监控，从而达到高可用。</li></ul><p>故障切换的过程是怎样的呢<br>假设主服务器宕机，哨兵 1 先检测到这个结果，系统并不会马上进行 failover 过程，仅仅是哨兵 1 主观的认为主服务器不可用，这个现象成为主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行 failover 操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线。这样对于客户端而言，一切都是透明的。</p><p>哨兵的工作模式如下：</p><ul><li>每个 Sentinel 以每秒钟一次的频率向它所知的 Master，Slave 以及其他 Sentinel 实例发送一个 PING 命令。</li><li>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel 标记为主观下线。</li><li>如果一个 Master 被标记为主观下线，则正在监视这个 Master 的所有 Sentinel 要以每秒一次的频率确认 Master 的确进入了主观下线状态。</li><li>当有足够数量的 Sentinel（大于等于配置文件指定的值）在指定的时间范围内确认 Master 的确进入了主观下线状态， 则 Master 会被标记为客观下线。</li><li>在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率向它已知的所有 Master，Slave 发送 INFO 命令。</li><li>当 Master 被 Sentinel 标记为客观下线时，Sentinel 向下线的 Master 的所有 Slave 发送 INFO 命令的频率会从 10 秒一次改为每秒一次</li><li>若没有足够数量的 Sentinel 同意 Master 已经下线， Master 的客观下线状态就会被移除；若 Master 重新向 Sentinel 的 PING 命令返回有效回复， Master 的主观下线状态就会被移除。</li></ul><h1 id="cluster集群模式"><a class="anchor" href="#cluster集群模式">#</a> Cluster 集群模式</h1><p>哨兵模式基于主从模式，实现读写分离，它还可以自动切换，系统可用性更高。但是它每个节点存储的数据是一样的，浪费内存，并且不好在线扩容。因此，Cluster 集群应运而生，它在 Redis3.0 加入的，实现了 Redis 的分布式存储。对数据进行分片，也就是说每台 Redis 节点上存储不同的内容，来解决在线扩容的问题。并且，它也提供复制和故障转移的功能。</p><p>一个 Redis 集群由多个节点组成，各个节点之间是怎么通信的呢？通过 Gossip 协议！<br>Redis Cluster 集群通过 Gossip 协议进行通信，节点之前不断交换信息，交换的信息内容包括节点出现故障、新节点加入、主从节点变更信息、slot 信息等等。常用的 Gossip 消息分为 4 种，分别是：ping、pong、meet、fail。</p><ul><li>meet 消息：通知新节点加入。消息发送者通知接收者加入到当前集群，meet 消息通信正常完成后，接收节点会加入到集群中并进行周期性的 ping、pong 消息交换。</li><li>ping 消息：集群内交换最频繁的消息，集群内每个节点每秒向多个其他节点发送 ping 消息，用于检测节点是否在线和交换彼此状态信息。</li><li>pong 消息：当接收到 ping、meet 消息时，作为响应消息回复给发送方确认消息正常通信。pong 消息内部封装了自身状态数据。节点也可以向集群内广播自身的 pong 消息来通知整个集群对自身状态进行更新。</li><li>fail 消息：当节点判定集群内另一个节点下线时，会向集群内广播一个 fail 消息，其他节点接收到 fail 消息之后把对应节点更新为下线状态。</li></ul><p>特别的，每个节点是通过<strong>集群总线 (cluster bus)</strong> 与其他的节点进行通信的。通讯时，使用特殊的端口号，即对外服务端口号加 10000。例如如果某个 node 的端口号是 6379，那么它与其它 nodes 通信的端口号是 16379。nodes 之间的通信采用特殊的二进制协议。</p><p>Hash Slot 插槽算法<br>既然是分布式存储，Cluster 集群使用的分布式算法是一致性 Hash 嘛？并不是，而是 Hash Slot 插槽算法。<br>插槽算法把整个数据库被分为 16384 个 slot（槽），每个进入 Redis 的键值对，根据 key 进行散列，分配到这 16384 插槽中的一个。使用的哈希映射也比较简单，用 CRC16 算法计算出一个 16 位的值，再对 16384 取模。数据库中的每个键都属于这 16384 个槽的其中一个，集群中的每个节点都可以处理这 16384 个槽。<br>集群中的每个节点负责一部分的 hash 槽，比如当前集群有 A、B、C 个节点，每个节点上的哈希槽数 =16384/3，那么就有：</p><ul><li>节点 A 负责 0~5460 号哈希槽</li><li>节点 B 负责 5461~10922 号哈希槽</li><li>节点 C 负责 10923~16383 号哈希槽</li></ul><p>Redis Cluster 集群中，需要确保 16384 个槽对应的 node 都正常工作，如果某个 node 出现故障，它负责的 slot 也会失效，整个集群将不能工作。<br>因此为了保证高可用，Cluster 集群引入了主从复制，一个主节点对应一个或者多个从节点。当其它主节点 ping 一个主节点 A 时，如果半数以上的主节点与 A 通信超时，那么认为主节点 A 宕机了。如果主节点宕机时，就会启用从节点。<br>在 Redis 的每一个节点上，都有两个玩意，一个是插槽（slot），它的取值范围是 0~16383。另外一个是 cluster，可以理解为一个集群管理的插件。当我们存取的 key 到达时，Redis 会根据 CRC16 算法得出一个 16 bit 的值，然后把结果对 16384 取模。酱紫每个 key 都会对应一个编号在 0~16383 之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作。<br>虽然数据是分开存储在不同节点上的，但是对客户端来说，整个集群 Cluster，被看做一个整体。客户端端连接任意一个 node，看起来跟操作单实例的 Redis 一样。当客户端操作的 key 没有被分配到正确的 node 节点时，Redis 会返回转向指令，最后指向正确的 node，这就有点像浏览器页面的 302 重定向跳转。</p><p>故障转移<br>Redis 集群实现了高可用，当集群内节点出现故障时，通过故障转移，以保证集群正常对外提供服务。<br>redis 集群通过 ping/pong 消息，实现故障发现。这个环境包括主观下线和客观下线。<br>主观下线： 某个节点认为另一个节点不可用，即下线状态，这个状态并不是最终的故障判定，只能代表一个节点的意见，可能存在误判情况。</p><p>主观下线<br>客观下线： 指标记一个节点真正的下线，集群内多个节点都认为该节点不可用，从而达成共识的结果。如果是持有槽的主节点故障，需要为该节点进行故障转移。<br>假如节点 A 标记节点 B 为主观下线，一段时间后，节点 A 通过消息把节点 B 的状态发到其它节点，当节点 C 接受到消息并解析出消息体时，如果发现节点 B 的 pfail 状态时，会触发客观下线流程；<br>当下线为主节点时，此时 Redis Cluster 集群为统计持有槽的主节点投票，看投票数是否达到一半，当下线报告统计数大于一半时，被标记为客观下线状态。</p><p>客观下线<strong>故障恢复</strong>：故障发现后，如果下线节点的是主节点，则需要在它的从节点中选一个替换它，以保证集群的高可用。流程如下：</p><ul><li>资格检查：检查从节点是否具备替换故障主节点的条件。</li><li>准备选举时间：资格检查通过后，更新触发故障选举时间。</li><li>发起选举：到了故障选举时间，进行选举。</li><li>选举投票：只有持有槽的<strong>主节点</strong>才有票，从节点收集到足够的选票（大于一半），触发<strong>替换主节点操作</strong></li></ul><h1 id="分布式锁"><a class="anchor" href="#分布式锁">#</a> 分布式锁</h1><p><strong>分布式锁</strong>，是控制分布式系统不同进程共同访问共享资源的一种锁的实现。秒杀下单、抢红包等等业务场景，都需要用到分布式锁，我们项目中经常使用 Redis 作为分布式锁。</p><h2 id="命令setnx-expire分开写"><a class="anchor" href="#命令setnx-expire分开写">#</a> 命令 setnx + expire 分开写</h2><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>（jedis.setnx(key,lock_value) == <span class="number">1</span>）&#123; </span><br><span class="line">    <span class="comment">//加锁 expire（key，100）; </span></span><br><span class="line">    <span class="comment">//设置过期时间 </span></span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        <span class="comment">//业务请求 do something </span></span><br><span class="line">    &#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">        jedis.del(key); </span><br><span class="line">        <span class="comment">//释放锁 </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果执行完 setnx 加锁，正要执行 expire 设置过期时间时，进程 crash 掉或者要重启维护了，那这个锁就 “长生不老” 了，别的线程永远获取不到锁啦，所以分布式锁不能这么实现。<p></p><h2 id="setnx-value值是过期时间"><a class="anchor" href="#setnx-value值是过期时间">#</a> setnx + value 值是过期时间</h2><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">expires</span> <span class="operator">=</span> System.currentTimeMillis() + expireTime; </span><br><span class="line"><span class="comment">//系统时间+设置的过期时间 </span></span><br><span class="line"><span class="type">String</span> <span class="variable">expiresStr</span> <span class="operator">=</span> String.valueOf(expires); </span><br><span class="line"><span class="comment">// 如果当前锁不存在，返回加锁成功 </span></span><br><span class="line"><span class="keyword">if</span> (jedis.setnx(key, expiresStr) == <span class="number">1</span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 如果锁已经存在，获取锁的过期时间 </span></span><br><span class="line"><span class="type">String</span> <span class="variable">currentValueStr</span> <span class="operator">=</span> jedis.get(key); </span><br><span class="line"><span class="comment">// 如果获取到的过期时间，小于系统当前时间，表示已经过期 </span></span><br><span class="line"><span class="keyword">if</span> (currentValueStr != <span class="literal">null</span> &amp;&amp; Long.parseLong(currentValueStr) &lt; System.currentTimeMillis()) &#123; </span><br><span class="line">    <span class="comment">// 锁已过期，获取上一个锁的过期时间，并设置现在锁的过期时间</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">oldValueStr</span> <span class="operator">=</span> jedis.getSet(key_resource_id, expiresStr); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (oldValueStr != <span class="literal">null</span> &amp;&amp; oldValueStr.equals(currentValueStr)) &#123; </span><br><span class="line">        <span class="comment">// 考虑多线程并发的情况，只有一个线程的设置值和当前值相同，它才可以加锁 </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//其他情况，均返回加锁失败 </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; </span><br></pre></td></tr></table></figure><br>这种方案也有这些缺点：<p></p><ul><li>过期时间是客户端自己生成的，分布式环境下，每个客户端的时间必须同步。</li><li>没有保存持有者的唯一标识，可能被别的客户端释放 / 解锁。</li><li>锁过期的时候，并发多个客户端同时请求过来，都执行了 jedis.getSet ()，最终只能有一个客户端加锁成功，但是该客户端锁的过期时间，可能被别的客户端覆盖。</li></ul><h2 id="set的扩展命令set-ex-px-nx注意可能存在的问题"><a class="anchor" href="#set的扩展命令set-ex-px-nx注意可能存在的问题">#</a> set 的扩展命令（set ex px nx）（注意可能存在的问题）</h2><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>（jedis.set(key, lock_value, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;EX&quot;</span>, 100s) == <span class="number">1</span>）&#123; </span><br><span class="line">    <span class="comment">//加锁 </span></span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        <span class="comment">//业务处理 do something  </span></span><br><span class="line">    &#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">        jedis.del(key); </span><br><span class="line">        <span class="comment">//释放锁 </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个方案可能存在这样的问题：<p></p><ul><li>锁过期释放了，业务还没执行完。</li><li>锁被别的线程误删。</li></ul><h1 id="redission"><a class="anchor" href="#redission">#</a> Redission</h1><p><strong>分布式锁</strong>可能存在<strong>锁过期释放，业务没执行完的问题</strong>。有些小伙伴认为，稍微把锁过期时间设置长一些就可以啦。其实我们设想一下，是否可以给获得锁的线程，开启一个定时守护线程，每隔一段时间检查锁是否还存在，存在则对锁的过期时间延长，防止锁过期提前释放。</p><p>只要线程一加锁成功，就会启动一个 watch dog 看门狗，它是一个后台线程，会每隔 10 秒检查一下，如果线程 1 还持有锁，那么就会不断的延长锁 key 的生存时间。因此，Redisson 就是使用 Redisson 解决了<strong>锁过期释放，业务没执行完</strong>问题。</p><h1 id="红锁redlock"><a class="anchor" href="#红锁redlock">#</a> 红锁 Redlock</h1><p>Redlock 核心思想是这样的：<br>搞多个 Redis master 部署，以保证它们不会同时宕掉。并且这些 master 节点是完全相互独立的，相互之间不存在数据同步。同时，需要确保在这多个 master 实例上，是与在 Redis 单实例，使用相同方法来获取和释放锁。<br>简化下步骤就是：</p><ul><li>按顺序向 5 个 master 节点请求加锁</li><li>根据设置的超时时间来判断，是不是要跳过该 master 节点。</li><li>如果大于等于三个节点加锁成功，并且使用的时间小于锁的有效期，即可认定加锁成功啦。</li><li>如果获取锁失败，解锁！</li></ul><h1 id="事务机制"><a class="anchor" href="#事务机制">#</a> 事务机制</h1><p>Redis 通过 MULTI、EXEC、WATCH 等一组命令集合，来实现事务机制。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p><p>简言之，Redis 事务就是顺序性、一次性、排他性的执行一个队列中的一系列命令。</p><p>Redis 执行事务的流程如下：</p><ul><li>开始事务（MULTI）</li><li>命令入队</li><li>执行事务（EXEC）</li><li>撤销事务（DISCARD ）</li></ul></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2024-04-17 20:28:55" itemprop="dateModified" datetime="2024-04-17T20:28:55+08:00">2024-04-17</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="lemon不是猫 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="lemon不是猫 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="lemon不是猫 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>lemon不是猫： </strong>lemon不是猫 <i class="ic i-at"><em>@</em></i>灵韵流光</li><li class="link"><strong>本文链接：</strong> <a href="https://lemon-not-cat.github.io/2024/03/31/redis/redis/" title="redis">https://lemon-not-cat.github.io/2024/03/31/redis/redis/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"></div><div class="item right"><a href="/2024/04/01/rjcs/rjcsbj/rjcsbj/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2024&#x2F;03&#x2F;31&#x2F;A6MmED4PvfwLeg3.png" title="软件测试笔记"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 软件测试笔记</span><h3>软件测试笔记</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">1.</span> <span class="toc-text">持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-aof"><span class="toc-number">1.1.</span> <span class="toc-text">1、AOF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-rdb"><span class="toc-number">1.2.</span> <span class="toc-text">2、RDB</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">2.</span> <span class="toc-text">缓存击穿、缓存穿透、缓存雪崩</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">2.1.</span> <span class="toc-text">缓存击穿</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">2.2.</span> <span class="toc-text">缓存穿透</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">2.3.</span> <span class="toc-text">缓存雪崩</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5"><span class="toc-number">3.</span> <span class="toc-text">过期策略</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-number">4.</span> <span class="toc-text">内存淘汰策略</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text">主从模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.</span> <span class="toc-text">哨兵模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cluster%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.</span> <span class="toc-text">Cluster 集群模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">8.</span> <span class="toc-text">分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4setnx-expire%E5%88%86%E5%BC%80%E5%86%99"><span class="toc-number">8.1.</span> <span class="toc-text">命令 setnx + expire 分开写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setnx-value%E5%80%BC%E6%98%AF%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="toc-number">8.2.</span> <span class="toc-text">setnx + value 值是过期时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#set%E7%9A%84%E6%89%A9%E5%B1%95%E5%91%BD%E4%BB%A4set-ex-px-nx%E6%B3%A8%E6%84%8F%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">8.3.</span> <span class="toc-text">set 的扩展命令（set ex px nx）（注意可能存在的问题）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redission"><span class="toc-number">9.</span> <span class="toc-text">Redission</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%A2%E9%94%81redlock"><span class="toc-number">10.</span> <span class="toc-text">红锁 Redlock</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6"><span class="toc-number">11.</span> <span class="toc-text">事务机制</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/2024/03/31/redis/redis/" rel="bookmark" title="redis">redis</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="lemon不是猫" data-src="/images/avatar.jpg"><p class="name" itemprop="name">lemon不是猫</p><div class="description" itemprop="description">对Java的探索 & 编程笔记</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">5</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">16</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">2</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xlbW9uLW5vdC1jYXQ=" title="https:&#x2F;&#x2F;github.com&#x2F;lemon-not-cat"><i class="ic i-github"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvbXkvbS9tdXNpYy9wbGF5bGlzdD9pZD0yMjI4OTQ2Njkw" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;my&#x2F;m&#x2F;music&#x2F;playlist?id&#x3D;2228946690"><i class="ic i-cloud-music"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/English/" title="分类于 英语">英语</a> <i class="ic i-angle-right"></i> <a href="/categories/English/CET-6/" title="分类于 CET-6">CET-6</a></div><span><a href="/2024/04/14/English/CET-6/CET-6/" title="CET-6">CET-6</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/redis/" title="分类于 Redis-缓存中间件">Redis-缓存中间件</a></div><span><a href="/2024/03/31/redis/redis/" title="redis">redis</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/rjcs/" title="分类于 软件测试">软件测试</a> <i class="ic i-angle-right"></i> <a href="/categories/rjcs/rjcsbj/" title="分类于 软件测试笔记">软件测试笔记</a></div><span><a href="/2024/04/01/rjcs/rjcsbj/rjcsbj/" title="软件测试笔记">软件测试笔记</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/gongxing/" title="分类于 公行">公行</a> <i class="ic i-angle-right"></i> <a href="/categories/gongxing/xingce/" title="分类于 行测">行测</a></div><span><a href="/2024/04/17/gongxing/xingce/" title="行测">行测</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/gongxing/" title="分类于 公行">公行</a> <i class="ic i-angle-right"></i> <a href="/categories/gongxing/gongji/" title="分类于 公基">公基</a></div><span><a href="/2024/04/17/gongxing/gongji/" title="公基">公基</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2023 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">lemon不是猫 @ Yume Kousatsu</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">22k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">20 分钟</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2024/03/31/redis/redis/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->